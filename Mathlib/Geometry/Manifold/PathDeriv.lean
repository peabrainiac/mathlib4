import Mathlib.Geometry.Manifold.Instances.UnitInterval
import Mathlib.Geometry.Manifold.Diffeomorph

open scoped Classical Manifold

local notation "‚Ñù¬π" => EuclideanSpace ‚Ñù (Fin 1)

universe uE uM

variable {E : Type uE} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (I : ModelWithCorners ‚Ñù E E)
  {M : Type uM} [TopologicalSpace M] [ChartedSpace E M] [SmoothManifoldWithCorners I M]

noncomputable section

def pathderiv {p q : M} (Œ≥ : Path p q) (t : unitInterval) : TangentSpace I (Œ≥ t) :=
  if t.val < 1 then ((mfderiv (ùì°‚àÇ 1) I Œ≥ t) (EuclideanSpace.single (0 : Fin 1) (1 : ‚Ñù)))
    else -((mfderiv (ùì°‚àÇ 1) I Œ≥ t) (EuclideanSpace.single (0 : Fin 1) (1 : ‚Ñù)))

def pathderivWithin {p q : M} (Œ≥ : Path p q) (s : Set unitInterval) (t : unitInterval) :
    TangentSpace I (Œ≥ t) :=
  if t.val < 1 then ((mfderivWithin (ùì°‚àÇ 1) I Œ≥ s t) (EuclideanSpace.single (0 : Fin 1) (1 : ‚Ñù)))
    else -((mfderivWithin (ùì°‚àÇ 1) I Œ≥ s t) (EuclideanSpace.single (0 : Fin 1) (1 : ‚Ñù)))

@[simp]
lemma pathderivWithin_univ {p q : M} (Œ≥ : Path p q) : pathderivWithin I Œ≥ Set.univ = pathderiv I Œ≥ := by
  simp [pathderiv,pathderivWithin]

lemma pathderivWithin_congr {p q p' q' : M} {Œ≥ : Path p q} {Œ≥' : Path p' q'} {s : Set unitInterval}
    {t : unitInterval} (hs : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t) (h : ‚àÄ t' ‚àà s, Œ≥ t' = Œ≥' t')
    (ht : Œ≥ t = Œ≥' t) : pathderivWithin I Œ≥ s t = pathderivWithin I Œ≥' s t := by
  rw [pathderivWithin,pathderivWithin,mfderivWithin_congr hs h ht]

lemma pathderivWithin_congr' {p q p' q' : M} {Œ≥ : Path p q} {Œ≥' : Path p' q'} {s : Set unitInterval}
    {t : unitInterval} (hs : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t) (h : ‚àÄ t' ‚àà s, Œ≥ t' = Œ≥' t')
    (ht : t ‚àà s) : pathderivWithin I Œ≥ s t = pathderivWithin I Œ≥' s t :=
  pathderivWithin_congr I hs h (h t ht)

lemma pathderivWithin_subset {p q : M} {Œ≥ : Path p q} {s u : Set unitInterval} {t : unitInterval}
    (hsu : s ‚äÜ u) (hs : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t)
    (h : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ u t) :
      pathderivWithin I Œ≥ s t = pathderivWithin I Œ≥ u t := by
  rw [pathderivWithin,pathderivWithin,mfderivWithin_subset hsu hs h]

lemma pathderivWithin_eq_pathderiv {p q : M} {Œ≥ : Path p q} {s : Set unitInterval}
    {t : unitInterval} (hs : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t) (h : MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ t) :
      pathderivWithin I Œ≥ s t = pathderiv I Œ≥ t := by
  rw [pathderivWithin_subset I s.subset_univ hs h.mdifferentiableWithinAt,pathderivWithin_univ]

-- TODO : replace proof with `rw [pathderivWithin,pathderiv,mfderivWithin_of_mem_nhds h]`
lemma pathderivWithin_of_mem_nhds {p q : M} {Œ≥ : Path p q} {s : Set unitInterval} {t : unitInterval}
    (h : s ‚àà nhds t) : pathderivWithin I Œ≥ s t = pathderiv I Œ≥ t := by
  rw [pathderivWithin,pathderiv,‚ÜêmfderivWithin_univ,‚Üês.univ_inter,mfderivWithin_inter h]

lemma pathderiv_zero_of_not_mdifferentiableAt {p q : M} {Œ≥ : Path p q} {t : unitInterval}
    (h : ¬¨MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ t) : pathderiv I Œ≥ t = 0 := by
  simp [pathderiv,mfderiv_zero_of_not_mdifferentiableAt h]

lemma pathderivWithin_zero_of_not_mdifferentiableWithinAt {p q : M} {Œ≥ : Path p q}
    {s : Set unitInterval} {t : unitInterval} (h : ¬¨MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ s t) :
      pathderivWithin I Œ≥ s t = 0 := by
  simp [pathderivWithin,mfderivWithin_zero_of_not_mdifferentiableWithinAt h]

lemma pathderivWithin_reparam {p q : M} {Œ≥ : Path p q} {f : unitInterval ‚Üí unitInterval}
    {hf : Continuous f} {hf‚ÇÄ : f 0 = 0} {hf‚ÇÅ : f 1 = 1} {s u : Set unitInterval}
    (t : unitInterval) (hŒ≥ : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ u (f t))
    (hf' : MDifferentiableWithinAt (ùì°‚àÇ 1) (ùì°‚àÇ 1) f s t) (hsu : s ‚äÜ f ‚Åª¬π' u)
    (hst : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t) :
      pathderivWithin I (Œ≥.reparam f hf hf‚ÇÄ hf‚ÇÅ) s t =
      (if t.val < 1 ‚àß (f t).val < 1 ‚à® ¬¨t.val < 1 ‚àß ¬¨(f t).val < 1
        then mfderivWithin (ùì°‚àÇ 1) (ùì°‚àÇ 1) f s t (EuclideanSpace.single 0 1) 0
        else -mfderivWithin (ùì°‚àÇ 1) (ùì°‚àÇ 1) f s t (EuclideanSpace.single 0 1) 0 : ‚Ñù)
       ‚Ä¢ (pathderivWithin I Œ≥ u (f t))
        := by
  have h : ‚Üë(mfderivWithin (ùì°‚àÇ 1) (ùì°‚àÇ 1) f s t) =
      fun x => (mfderivWithin (ùì°‚àÇ 1) (ùì°‚àÇ 1) f s t (EuclideanSpace.single 0 1) 0) ‚Ä¢ x := by
    refine' funext fun x => (PiLp.ext (Unique.forall_iff.mpr _) : @Eq ‚Ñù¬π _ _)
    have hx : x = (x 0) ‚Ä¢ (EuclideanSpace.single 0 1 : ‚Ñù¬π) := PiLp.ext fun i => by
      simp [((Fin.eq_zero i) ‚ñ∏ rfl : x 0 = x i)]
    rw [PiLp.smul_apply,smul_eq_mul,mul_comm,hx,map_smul,PiLp.smul_apply _ _ (_ : ‚Ñù¬π)]
    simp
  rw [pathderivWithin,pathderivWithin,Path.coe_reparam,mfderivWithin_comp t hŒ≥ hf' hsu hst]
  by_cases ht : t.val < 1
  all_goals by_cases ht' : (f t).val < 1
  all_goals simp only [ht,ht',ite_true,ite_false,ContinuousLinearMap.comp_apply]
  all_goals nth_rewrite 1 [h]
  all_goals simp

lemma Path.symm_mdifferentiableWithinAt_iff {p q : M} {Œ≥ : Path p q} {s : Set unitInterval}
    {t : unitInterval} : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥.symm s t ‚Üî
      MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.symm '' s) (unitInterval.symm t) := by
  have h {p q : M} (Œ≥ : Path p q) (s : Set unitInterval) (t : unitInterval) : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥.symm s t ‚Üí
      MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.symm '' s) (unitInterval.symm t) := fun h' => by
    rw [‚ÜêFunction.comp.right_id Œ≥,‚ÜêunitInterval.symm_comp_symm,‚ÜêFunction.comp.assoc _ _ _]
    rw [‚ÜêunitInterval.symm_symm_image s,‚ÜêunitInterval.symm_symm t] at h'
    exact h'.comp _ unitInterval.smooth_symm.mdifferentiableWithinAt (Set.subset_preimage_image _ _)
  have h' := h Œ≥.symm (unitInterval.symm '' s) (unitInterval.symm t)
  rw [unitInterval.symm_symm_image s,unitInterval.symm_symm t,Path.symm_symm] at h'
  exact ‚ü®h Œ≥ s t,h'‚ü©

lemma Path.symm_mdifferentiableAt_iff {p q : M} {Œ≥ : Path p q} {t : unitInterval} :
    MDifferentiableAt (ùì°‚àÇ 1) I Œ≥.symm t ‚Üî MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.symm t) := by
  have h {p q : M} (Œ≥ : Path p q) (t : unitInterval) :
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥.symm t ‚Üí MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.symm t) := fun h' => by
    rw [‚ÜêFunction.comp.right_id Œ≥,‚ÜêunitInterval.symm_comp_symm,‚ÜêFunction.comp.assoc _ _ _]
    exact MDifferentiableAt.comp (unitInterval.symm t) ((unitInterval.symm_symm t).symm ‚ñ∏ h') unitInterval.smooth_symm.mdifferentiableAt
  have h' := unitInterval.symm_symm t ‚ñ∏ (@Path.symm_symm _ _ _ _ Œ≥) ‚ñ∏ (h Œ≥.symm (unitInterval.symm t))
  exact ‚ü®h Œ≥ t,h'‚ü©

lemma Path.pathderivWithin_of_symm {p q : M} {Œ≥ : Path p q} {s : Set unitInterval}
    {t : unitInterval} (hst : UniqueMDiffWithinAt (ùì°‚àÇ 1) s t) : pathderivWithin I Œ≥.symm s t =
      -pathderivWithin I Œ≥ (unitInterval.symm '' s) (unitInterval.symm t) := by
  rw [pathderivWithin,pathderivWithin]
  by_cases hŒ≥ : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.symm '' s) (unitInterval.symm t)
  rw [Path.symm,Path.coe_mk_mk,mfderivWithin_comp t hŒ≥ unitInterval.smooth_symm.mdifferentiableWithinAt
    (s.subset_preimage_image unitInterval.symm) hst,
    mfderivWithin_subset s.subset_univ hst unitInterval.smooth_symm.mdifferentiableWithinAt,
    mfderivWithin_univ]
  by_cases ht : 0 < t.val ‚àß t.val < 1
  simp [unitInterval.mfderiv_symm,ht]
  obtain ht' | ht' := not_and_or.mp ht
  simp [unitInterval.mfderiv_symm,ht',lt_of_le_of_lt (le_of_not_lt ht') zero_lt_one]
  simp [unitInterval.mfderiv_symm,ht',lt_of_lt_of_le zero_lt_one (le_of_not_lt ht')]
  have hŒ≥' := (not_iff_not.mpr (symm_mdifferentiableWithinAt_iff I)).mpr hŒ≥
  simp [mfderivWithin_zero_of_not_mdifferentiableWithinAt hŒ≥,
    mfderivWithin_zero_of_not_mdifferentiableWithinAt hŒ≥']

lemma Path.pathderiv_of_symm {p q : M} {Œ≥ : Path p q} {t : unitInterval} : pathderiv I Œ≥.symm t =
    -pathderiv I Œ≥ (unitInterval.symm t) := by
  have h : Set.range unitInterval.symm = Set.univ := unitInterval.symm_toDiffeomorph.toEquiv.range_eq_univ
  rw [‚ÜêpathderivWithin_univ,pathderivWithin_of_symm I (uniqueMDiffWithinAt_univ (ùì°‚àÇ 1))]
  simp [h]

-- TODO : move to Mathlib.Topology.Connected.PathConnected
lemma Path.coe_symm {p q : M} (Œ≥ : Path p q) : ‚ÜëŒ≥.symm = ‚ÜëŒ≥ ‚àò unitInterval.symm := rfl

lemma Path.trans_eqOn_left {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Set.EqOn (Œ≥.trans Œ≥') (Œ≥ ‚àò unitInterval.double) {t | t.val ‚â§ 1 / 2} := fun t ht => by
  have ht' : 2 * t.val ‚àà unitInterval := ‚ü®mul_nonneg zero_lt_two.le t.2.1,(le_div_iff' zero_lt_two).mp ht‚ü©
  simp [trans,(one_div (2 : ‚Ñù)) ‚ñ∏ ht.out,Œ≥.extend_extends ht',
    Subtype.coe_eq_of_eq_mk (unitInterval.coe_double_eq t),ht'.out]

lemma Path.trans_eqOn_right {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Set.EqOn (Œ≥.trans Œ≥') (Œ≥' ‚àò unitInterval.double') {t | 1 / 2 ‚â§ t.val} := fun t ht => by
  by_cases ht' : t.val = 1 / 2
  simp [trans,(one_div (2 : ‚Ñù)) ‚ñ∏ ht',unitInterval.double']
  have ht'' := Ne.lt_of_le (Ne.symm ht') ht.out
  have ht''' : 2 * t.val - 1 ‚àà unitInterval := ‚ü®by linarith,by linarith [t.2.2]‚ü©
  simp [trans,(one_div (2 : ‚Ñù)) ‚ñ∏ ht''.not_le,Œ≥'.extend_extends ht''',
    Subtype.coe_eq_of_eq_mk (unitInterval.coe_double'_eq t),max_eq_right ht'''.out.1]

lemma Path.trans_eqOn_left' {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Set.EqOn (Œ≥.trans Œ≥') (Œ≥.reparam unitInterval.double unitInterval.continuous_double
      unitInterval.double_zero unitInterval.double_one) {t | t.val ‚â§ 1 / 2} := Path.trans_eqOn_left

lemma Path.trans_eqOn_right' {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Set.EqOn (Œ≥.trans Œ≥') (Œ≥'.reparam unitInterval.double' unitInterval.continuous_double'
      unitInterval.double'_zero unitInterval.double'_one) {t | 1 / 2 ‚â§ t.val} := Path.trans_eqOn_right

lemma Path.trans_comp_half {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Œ≥.trans Œ≥' ‚àò unitInterval.half = Œ≥ := funext fun t => by
  simp [-one_div,trans,div_le_div_of_le two_pos.le t.2.2,mul_div_cancel']

lemma Path.trans_comp_half' {p p' p'' : M} {Œ≥ : Path p p'} {Œ≥' : Path p' p''} :
    Œ≥.trans Œ≥' ‚àò unitInterval.half' = Œ≥' := funext fun t => by
  simp only [unitInterval.half'_eq_symm_half_symm,‚ÜêFunction.comp.assoc,‚Üêcoe_symm,trans_symm,
    trans_comp_half,symm_symm]

lemma Path.trans_mdifferentiableWithinAt_left_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val ‚â§ 1 / 2) {u : Set unitInterval} :
    MDifferentiableWithinAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') (unitInterval.double ‚Åª¬π' u ‚à© {s | s.val ‚â§ 1 / 2}) t ‚Üî
      MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ u (unitInterval.double t) := by
  refine' ‚ü®fun hŒ≥ => _,fun hŒ≥ => _‚ü©
  rw [‚Üêtrans_comp_half (Œ≥' := Œ≥')]
  refine' ((unitInterval.half_double ht).symm ‚ñ∏ hŒ≥).comp _ _ _
  exact unitInterval.smooth_half.mdifferentiableWithinAt
  simp [-one_div,‚ÜêSet.preimage_comp,unitInterval.double_comp_half,subset_rfl,
    (show u ‚äÜ {s | s.val / 2 ‚â§ 1 / 2} by exact fun s _ => div_le_div_of_le two_pos.le s.2.2)]
  have hs := (unitInterval.double ‚Åª¬π' u).inter_subset_right {s | s.val ‚â§ 1 / 2}
  have h := ((unitInterval.smoothOn_double t ht).mono hs).mdifferentiableWithinAt le_top
  exact (hŒ≥.comp t h (Set.inter_subset_left _ _)).congr (fun t ht => trans_eqOn_left ht.2) (trans_eqOn_left ht)

lemma Path.trans_mdifferentiableWithinAt_left_iff' {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val ‚â§ 1 / 2) :
    MDifferentiableWithinAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') {s | s.val ‚â§ 1 / 2} t ‚Üî
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.double t) := by
  rw [‚ÜêmdifferentiableWithinAt_univ,‚ÜêSet.univ_inter {s : unitInterval | s.val ‚â§ 1 / 2}]
  exact Set.preimage_univ ‚ñ∏ trans_mdifferentiableWithinAt_left_iff I Œ≥ Œ≥' ht

lemma Path.trans_mdifferentiableAt_left_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val < 1 / 2) :
    MDifferentiableAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') t ‚Üî
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ (unitInterval.double t) := by
  simp_rw [‚ÜêmdifferentiableWithinAt_univ]
  rw [‚ÜêmdifferentiableWithinAt_inter (t := {s | s.val ‚â§ 1 / 2})]
  exact Set.preimage_univ ‚ñ∏ trans_mdifferentiableWithinAt_left_iff I Œ≥ Œ≥' ht.le
  exact (mem_nhds_subtype _ t _).mpr ‚ü®Set.Iic (1 / 2),‚ü®Iic_mem_nhds ht,subset_of_eq rfl‚ü©‚ü©

lemma Path.trans_mdifferentiableWithinAt_right_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : 1 / 2 ‚â§ t.val) {u : Set unitInterval} :
    MDifferentiableWithinAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') (unitInterval.double' ‚Åª¬π' u ‚à© {s | 1 / 2 ‚â§ s.val}) t ‚Üî
      MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥' u (unitInterval.double' t) := by
  refine' ‚ü®fun hŒ≥' => _, fun hŒ≥' => _‚ü©
  rw [‚Üêtrans_comp_half' (Œ≥ := Œ≥)]
  refine' ((unitInterval.half'_double' ht).symm ‚ñ∏ hŒ≥').comp _ _ _
  exact unitInterval.smooth_half'.mdifferentiableWithinAt
  simp [-one_div,‚ÜêSet.preimage_comp,unitInterval.double'_comp_half',subset_rfl,
    (show u ‚äÜ {s | 1 / 2 ‚â§ (s.val + 1) / 2} by exact fun s _ => Set.mem_setOf.mpr (by linarith [s.2.1]))]
  have hs := (unitInterval.double' ‚Åª¬π' u).inter_subset_right {s | 1 / 2 ‚â§ s.val}
  have h := ((unitInterval.smoothOn_double' t ht).mono hs).mdifferentiableWithinAt le_top
  exact (hŒ≥'.comp t h (Set.inter_subset_left _ _)).congr (fun t ht => trans_eqOn_right ht.2) (trans_eqOn_right ht)

lemma Path.trans_mdifferentiableWithinAt_right_iff' {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : 1 / 2 ‚â§ t.val) :
    MDifferentiableWithinAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') {s | 1 / 2 ‚â§ s.val} t ‚Üî
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥' (unitInterval.double' t) := by
  rw [‚ÜêmdifferentiableWithinAt_univ,‚ÜêSet.univ_inter {s : unitInterval | 1 / 2 ‚â§ s.val}]
  exact Set.preimage_univ ‚ñ∏ trans_mdifferentiableWithinAt_right_iff I Œ≥ Œ≥' ht

lemma Path.trans_mdifferentiableAt_right_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val > 1 / 2) :
    MDifferentiableAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') t ‚Üî
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥' (unitInterval.double' t) := by
  rw [‚Üê(Œ≥.trans Œ≥').symm_symm,trans_symm,symm_mdifferentiableAt_iff,
    trans_mdifferentiableAt_left_iff I _ _ (by rw [unitInterval.coe_symm_eq]; linarith),
    symm_mdifferentiableAt_iff,unitInterval.double_symm,unitInterval.symm_symm]

lemma Path.trans_pathderivWithin_left {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val ‚â§ 1 / 2) {u : Set unitInterval}
    (hu : UniqueMDiffWithinAt (ùì°‚àÇ 1) (unitInterval.double ‚Åª¬π' u ‚à© {s | s.val ‚â§ 1 / 2}) t) :
      pathderivWithin I (Œ≥.trans Œ≥') (unitInterval.double ‚Åª¬π' u ‚à© {s | s.val ‚â§ 1 / 2}) t =
        (2 : ‚Ñù) ‚Ä¢ pathderivWithin I Œ≥ u (unitInterval.double t) := by
  by_cases hŒ≥ : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥ u (unitInterval.double t)
  rw [pathderivWithin_congr I hu (Path.trans_eqOn_left'.mono (Set.inter_subset_right _ _))
    (Path.trans_eqOn_left ht),pathderivWithin_reparam I _ hŒ≥ _ (Set.inter_subset_left _ _) hu,
    mfderivWithin_subset (Set.inter_subset_right _ _) hu _,unitInterval.mfderivWithin_double ht]
  by_cases ht' : t.val < 1 / 2
  simp only [ht',ite_true,ContinuousLinearMap.coe_smul',Pi.smul_apply,ContinuousLinearMap.id]
  simp [-one_div,lt_of_le_of_lt ht one_half_lt_one,(lt_div_iff' zero_lt_two).mp ht']
  simp only [ht',ite_false,ContinuousLinearMap.coe_smul',Pi.smul_apply,ContinuousLinearMap.id]
  simp [-one_div,lt_of_le_of_lt ht one_half_lt_one,ht',(lt_div_iff' zero_lt_two).not.mp ht']
  exact unitInterval.smoothOn_double.mdifferentiableOn t ht
  exact (unitInterval.smoothOn_double.mdifferentiableOn t ht).mono (Set.inter_subset_right _ _)
  rw [pathderivWithin_zero_of_not_mdifferentiableWithinAt I hŒ≥,
    pathderivWithin_zero_of_not_mdifferentiableWithinAt I _,smul_zero]
  exact (trans_mdifferentiableWithinAt_left_iff I Œ≥ Œ≥' ht).not.mpr hŒ≥

lemma Path.trans_pathderivWithin_left' {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : t.val ‚â§ 1 / 2) :
      pathderivWithin I (Œ≥.trans Œ≥') {s | s.val ‚â§ 1 / 2} t =
        (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥ (unitInterval.double t) := by
  rw [‚ÜêpathderivWithin_univ,‚ÜêSet.univ_inter {s : unitInterval | s.val ‚â§ 1 / 2}]
  convert Set.preimage_univ ‚ñ∏ trans_pathderivWithin_left I Œ≥ Œ≥' ht _
  rw [Set.preimage_univ,Set.univ_inter]
  exact unitInterval.uniqueMDiffOn_left t ht

lemma Path.trans_pathderiv_left {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'') {t : unitInterval}
    (ht : t.val < 1 / 2) :
      pathderiv I (Œ≥.trans Œ≥') t = (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥ (unitInterval.double t) := by
  rw [‚Üêtrans_pathderivWithin_left' I Œ≥ Œ≥' ht.le,pathderivWithin_of_mem_nhds I _]
  exact (mem_nhds_subtype _ t _).mpr ‚ü®Set.Iic (1 / 2),‚ü®Iic_mem_nhds ht,subset_of_eq rfl‚ü©‚ü©

lemma Path.trans_pathderivWithin_right {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : 1 / 2 ‚â§ t.val) {u : Set unitInterval}
    (hu : UniqueMDiffWithinAt (ùì°‚àÇ 1) (unitInterval.double' ‚Åª¬π' u ‚à© {s | 1 / 2 ‚â§ s.val}) t) :
      pathderivWithin I (Œ≥.trans Œ≥') (unitInterval.double' ‚Åª¬π' u ‚à© {s | 1 / 2 ‚â§ s.val}) t =
        (2 : ‚Ñù) ‚Ä¢ pathderivWithin I Œ≥' u (unitInterval.double' t) := by
  by_cases hŒ≥' : MDifferentiableWithinAt (ùì°‚àÇ 1) I Œ≥' u (unitInterval.double' t)
  rw [pathderivWithin_congr I hu (Path.trans_eqOn_right'.mono (Set.inter_subset_right _ _))
    (Path.trans_eqOn_right ht),pathderivWithin_reparam I _ hŒ≥' _ (Set.inter_subset_left _ _) hu,
    mfderivWithin_subset (Set.inter_subset_right _ _) hu _,unitInterval.mfderivWithin_double' ht]
  by_cases ht' : t.val < 1
  simp only [ht',ite_true,ContinuousLinearMap.coe_smul',Pi.smul_apply,ContinuousLinearMap.id]
  simp [-one_div,(by linarith : 2 * t.val - 1 < 1)]
  simp only [ht',ite_true,ContinuousLinearMap.coe_smul',Pi.smul_apply,ContinuousLinearMap.id]
  simp [-one_div,(by linarith : ¬¨ 2 * t.val - 1 < 1)]
  exact unitInterval.smoothOn_double'.mdifferentiableOn t ht
  exact (unitInterval.smoothOn_double'.mdifferentiableOn t ht).mono (Set.inter_subset_right _ _)
  rw [pathderivWithin_zero_of_not_mdifferentiableWithinAt I hŒ≥',
    pathderivWithin_zero_of_not_mdifferentiableWithinAt I _,smul_zero]
  exact (trans_mdifferentiableWithinAt_right_iff I Œ≥ Œ≥' ht).not.mpr hŒ≥'

lemma Path.trans_pathderivWithin_right' {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : 1 / 2 ‚â§ t.val) :
      pathderivWithin I (Œ≥.trans Œ≥') {s | 1 / 2 ‚â§ s.val} t =
        (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥' (unitInterval.double' t) := by
  rw [‚ÜêpathderivWithin_univ,‚ÜêSet.univ_inter {s : unitInterval | 1 / 2 ‚â§ s.val}]
  convert Set.preimage_univ ‚ñ∏ trans_pathderivWithin_right I Œ≥ Œ≥' ht _
  rw [Set.preimage_univ,Set.univ_inter]
  exact unitInterval.uniqueMDiffOn_right t ht

lemma Path.trans_pathderiv_right {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'')
    {t : unitInterval} (ht : 1 / 2 < t.val) :
      pathderiv I (Œ≥.trans Œ≥') t = (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥' (unitInterval.double' t) := by
  rw [‚Üêtrans_pathderivWithin_right' I Œ≥ Œ≥' ht.le,pathderivWithin_of_mem_nhds I _]
  exact (mem_nhds_subtype _ t _).mpr ‚ü®Set.Ici (1 / 2),‚ü®Ici_mem_nhds ht,subset_of_eq rfl‚ü©‚ü©

lemma Path.trans_mdifferentiableAt_mid_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'') :
    MDifferentiableAt (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') unitInterval.one_half ‚Üî
      MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ 1 ‚àß MDifferentiableAt (ùì°‚àÇ 1) I Œ≥' 0 ‚àß
        pathderiv I Œ≥ 1 = pathderiv I Œ≥' 0 := by
  rw [‚ÜêunitInterval.double_one_half,‚ÜêunitInterval.double'_one_half]
  refine' ‚ü®fun h => ‚ü®_,_,_‚ü©,fun ‚ü®hŒ≥,hŒ≥',h‚ü© => _‚ü©
  exact (trans_mdifferentiableWithinAt_left_iff' I Œ≥ Œ≥' (by simp)).mp h.mdifferentiableWithinAt
  exact (trans_mdifferentiableWithinAt_right_iff' I Œ≥ Œ≥' (by simp)).mp h.mdifferentiableWithinAt
  rw [‚Üêsmul_right_inj (R := ‚Ñù) two_ne_zero,‚Üêtrans_pathderivWithin_left' I Œ≥ Œ≥' (by simp),
    ‚Üêtrans_pathderivWithin_right' I Œ≥ Œ≥' (by simp),
    pathderivWithin_eq_pathderiv I (unitInterval.uniqueMDiffOn_left _ (by simp)) h,
    pathderivWithin_eq_pathderiv I (unitInterval.uniqueMDiffOn_right _ (by simp)) h]
  refine' (HasMFDerivWithinAt.hasMFDerivAt _ Filter.univ_mem).mdifferentiableAt
  convert (MDifferentiableWithinAt.hasMFDerivWithinAt _).union (s := {s | s.val ‚â§ 1 / 2})
    (t := {s : unitInterval | 1 / 2 ‚â§ s.val}) _
  ext; simp [le_total]
  exact (trans_mdifferentiableWithinAt_left_iff' I Œ≥ Œ≥' (by simp)).mpr hŒ≥
  convert ((trans_mdifferentiableWithinAt_right_iff' I Œ≥ Œ≥' (by simp)).mpr hŒ≥').hasMFDerivWithinAt
    using 1
  rw [‚Üê(smul_right_inj (R := ‚Ñù) two_ne_zero),‚Üêtrans_pathderivWithin_left' I Œ≥ Œ≥' (by simp),
    ‚Üêtrans_pathderivWithin_right' I Œ≥ Œ≥' (by simp)] at h
  simp_rw [pathderivWithin,unitInterval.coe_one_half,one_half_lt_one,ite_true] at h
  ext x
  have hx : x = (x 0) ‚Ä¢ (EuclideanSpace.single 0 1 : ‚Ñù¬π) := PiLp.ext fun i => by
    simp [((Fin.eq_zero i) ‚ñ∏ rfl : x 0 = x i)]
  rw [hx,map_smul,map_smul,h]

lemma Path.trans_mdifferentiable_iff {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'') :
    MDifferentiable (ùì°‚àÇ 1) I (Œ≥.trans Œ≥') ‚Üî MDifferentiable (ùì°‚àÇ 1) I Œ≥ ‚àß
      MDifferentiable (ùì°‚àÇ 1) I Œ≥' ‚àß pathderiv I Œ≥ 1 = pathderiv I Œ≥' 0 := by
  refine' ‚ü®fun h => ‚ü®fun t => _,fun t => _,_‚ü©,fun ‚ü®hŒ≥,hŒ≥',h‚ü© t => _‚ü©
  rw [‚ÜêunitInterval.double_half t,‚Üêtrans_mdifferentiableWithinAt_left_iff' I Œ≥ Œ≥' _]
  exact (h _).mdifferentiableWithinAt
  rw [unitInterval.coe_half_eq]; linarith [t.2.2]
  rw [‚ÜêunitInterval.double'_half' t,‚Üêtrans_mdifferentiableWithinAt_right_iff' I Œ≥ Œ≥' _]
  exact (h _).mdifferentiableWithinAt
  rw [unitInterval.coe_half'_eq]; linarith [t.2.1]
  refine' ((trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').mp (h _)).2.2
  by_cases ht : t.val < 1 / 2
  exact (trans_mdifferentiableAt_left_iff I Œ≥ Œ≥' ht).mpr (hŒ≥ _)
  by_cases ht' : 1 / 2 < t.val
  exact (trans_mdifferentiableAt_right_iff I Œ≥ Œ≥' ht').mpr (hŒ≥' _)
  convert (trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').mpr ‚ü®hŒ≥ _,hŒ≥' _,h‚ü©
  exact Subtype.ext (eq_of_le_of_not_lt (le_of_not_lt ht') ht)

lemma Path.trans_pathderiv {p p' p'' : M} (Œ≥ : Path p p') (Œ≥' : Path p' p'') {t : unitInterval} :
    pathderiv I (Œ≥.trans Œ≥') t =
      if t.val < 1 / 2 then (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥ (unitInterval.double t)
      else if t.val > 1 / 2 then (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥' (unitInterval.double' t)
      else if pathderiv I Œ≥ 1 = pathderiv I Œ≥' 0 then (2 : ‚Ñù) ‚Ä¢ pathderiv I Œ≥ 1 else 0 := by
  by_cases ht : t.val < 1 / 2
  all_goals simp only [ht,ite_true,ite_false]
  exact trans_pathderiv_left I Œ≥ Œ≥' ht
  by_cases ht' : 1 / 2 < t.val
  all_goals simp only [ht',ite_true,ite_false]
  exact trans_pathderiv_right I Œ≥ Œ≥' ht'
  rw [(Subtype.ext (eq_of_le_of_not_lt (le_of_not_lt ht') ht) : t = unitInterval.one_half)]
  by_cases h : pathderiv I Œ≥ 1 = pathderiv I Œ≥' 0
  simp_rw [eq_true h,ite_true]
  by_cases hŒ≥ : MDifferentiableAt (ùì°‚àÇ 1) I Œ≥ 1
  by_cases hŒ≥' : MDifferentiableAt (ùì°‚àÇ 1) I Œ≥' 0
  have h' := (trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').mpr ‚ü®hŒ≥,hŒ≥',h‚ü©
  rw [‚ÜêpathderivWithin_eq_pathderiv I (unitInterval.uniqueMDiffOn_left _ (by simp)) h',
    ‚ÜêunitInterval.double_one_half,trans_pathderivWithin_left' I Œ≥ Œ≥' (by simp)]
  rw [h,pathderiv_zero_of_not_mdifferentiableAt I hŒ≥',smul_zero,
    pathderiv_zero_of_not_mdifferentiableAt I ((trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').not.mpr _)]
  tauto
  rw [pathderiv_zero_of_not_mdifferentiableAt I hŒ≥,smul_zero,
    pathderiv_zero_of_not_mdifferentiableAt I ((trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').not.mpr _)]
  tauto
  simp only [h,ite_false]
  apply pathderiv_zero_of_not_mdifferentiableAt I
  refine' (trans_mdifferentiableAt_mid_iff I Œ≥ Œ≥').not.mpr (by tauto)
